ccp_handshake_protocol:
  meta:
    name: "CCP Handshake Specification"
    version: "2.0"
    status: "Draft-Stable"
    maintainer: "VCDesign Project"

  purpose: >
    CCP Handshake is the minimal protocol for AI to autonomously construct interfaces on the fly.
    Continuity of value is maintained only when the Boundary (World) and Responsibility are aligned.
    
    Guarantees:
    - Declaration of Boundary
    - Continuity of Responsibility
    - Explication of Decision Authority
    - Handling of Δ and R
    - Safety of Mid-stream Reversal

  design_principles:
    boundary_first: "AI does not infer purpose. First, it declares 'which World to converse in'."
    responsibility_continuity: "Decisions must not be closed arbitrarily by AI. Follow RC to clarify Δ and R positions."
    determinability_gate: "Structurally determine the conditions under which AI is allowed to close decisions (BOA/RCA)."
    decision_closure_safety: "Check whether AI is allowed to close decisions via 5 Validation Steps (DCS)."
    minimality: "Eliminate unnecessary semantic inference or implicit assumptions."

  schema_definition:
    $schema: "https://yaml-schema.org/draft-01"
    title: "CCP Minimal Handshake Schema"
    version: "2.0"
    type: object
    required:
      - handshake_meta
      - world
      - agent
      - trust
      - interface
      - cost_model
      - decision_authority
      - resolution_policy
      - reversal_signal
      - continuity_claim
    
    properties:
      handshake_meta:
        type: object
        required: [handshake_id, timestamp, expires_at, nonce, participants]
        properties:
          handshake_id: { type: string }
          timestamp:    { type: string }
          expires_at:   { type: string }
          nonce:        { type: string }
          participants:
            type: object
            required: [initiator, receiver]
            properties:
              initiator: { type: string }
              receiver:  { type: string }
      
      world:
        type: object
        required: [id, version]
        properties:
          id:        { type: string }
          version:   { type: string }
          description: { type: string }

      agent:
        type: object
        required: [id, provider]
        properties:
          id:        { type: string }
          provider:  { type: string }
          capabilities: { type: array, items: { type: string } }
          limitations:  { type: array, items: { type: string } }

      trust:
        type: object
        required: [validation_level, risk_level, scope]
        properties:
          validation_level:
            type: string
            enum: ["raw", "syntax", "semantic", "attested"]
          risk_level:
            type: integer
            minimum: 0
            maximum: 3
          scope:
            type: string
            enum: ["local_session", "project", "organization"]
          evidence:
            type: array
            items:
              type: object
              required: [type, issuer]
              properties:
                type:     { type: string }
                issuer:   { type: string }
                reference: { type: string }

      interface:
        type: object
        required: [input, output, semantics]
        properties:
          input:
            type: object
            required: [format]
            properties:
              format: { type: string, enum: ["json", "yaml", "text"] }
              schema_ref: { type: string }
          output:
            type: object
            required: [format]
            properties:
              format: { type: string, enum: ["json", "yaml", "text"] }
              schema_ref: { type: string }
          semantics:
            type: object
            required: [intent]
            properties:
              intent:
                type: string
                enum: ["proposal", "advice", "decision"]
              meaning_scope: { type: string }
              irreversible:  { type: boolean }

      cost_model:
        type: object
        required: [max_tokens, max_latency_ms]
        properties:
          max_tokens:     { type: integer }
          max_latency_ms: { type: integer }
          billing_unit:   { type: string, enum: ["per_1k_tokens", "per_request"] }
          priority:       { type: string, enum: ["low", "normal", "high"] }

      decision_authority:
        type: object
        required: [initial_state, domain, allowed_transitions]
        properties:
          initial_state:
            type: string
            enum: ["Human-Closed", "AI-Closed"]
          domain:
            type: string
            enum: ["meaning", "responsibility", "execution"]
          allowed_transitions:
            type: array
            items:
              type: string
              enum: ["AI→Human", "Human→AI"]
          escalation_rules:
            type: array
            items:
              type: object
              required: [condition, action]
              properties:
                condition: { type: string }
                action:
                  type: string
                  enum: ["AI→Human", "Human→AI"]

      resolution_policy:
        type: object
        required: [delta_transfer, resolver]
        properties:
          delta_transfer:
            type: object
            required: [allowed, scope, redaction]
            properties:
              allowed:   { type: boolean }
              scope:
                type: string
                enum: ["prompt", "artifact", "state", "tool_call"]
              redaction:
                type: string
                enum: ["required", "optional", "forbidden"]
          resolver:
            type: object
            required: [default]
            properties:
              default:
                type: string
                enum: ["initiator", "receiver", "negotiated"]
              rules:
                type: array
                items:
                  type: object
                  required: [condition, resolver]
                  properties:
                    condition: { type: string }
                    resolver:
                      type: string
                      enum: ["initiator", "receiver", "negotiated"]

      reversal_signal:
        type: object
        required: [enabled, events]
        properties:
          enabled: { type: boolean }
          events:
            type: array
            items:
              type: object
              required: [type]
              properties:
                type:
                  type: string
                  enum: ["validation_fail", "authority_revoked"]
                payload:
                  type: object
                  properties:
                    phase:  { type: string }
                    reason: { type: string }
          behavior:
            type: object
            properties:
              on_reversal:
                type: array
                items: { type: string }

      continuity_claim:
        type: object
        required: [id, boundary_def, signature_schema]
        properties:
          id: { type: string }
          boundary_def:
            type: object
            required: [responsibility_id, meaning_scope, context_assumption]
            properties:
              responsibility_id: { type: string }
              meaning_scope:     { type: string }
              context_assumption: { type: string }
          signature_schema:
            type: object
            required: [algorithm, canonicalization, signed_fields, public_key]
            properties:
              algorithm:
                type: string
                enum: ["ed25519", "rsa-sha256"]
              canonicalization:
                type: string
                enum: ["json_c14n", "yaml_c14n"]
              signed_fields:
                type: array
                items: { type: string }
              public_key: { type: string }
              key_ref:    { type: string }

  protocol_flow:
    States:
      HELLO: "Session start, exchange of handshake_meta"
      OFFER: "Initiator sends handshake proposal"
      ACCEPT: "Receiver approves proposal"
      REJECT: "Receiver rejects"
      REVERSE: "Mid-stream reversal based on DCS/BOA/RC"

    Sequence:
      HELLO:
        sent: [handshake_meta, world.id, agent.id, trust.validation_level]
        checks: [timestamp ±5min, nonce unused, signature_schema valid]
      
      OFFER:
        sent: [interface, cost_model, decision_authority, resolution_policy, continuity_claim]
        checks:
          - "validation_level >= semantic"
          - "intent=decision -> risk_level >= 2"
          - "irreversible=true -> initial_state=Human-Closed"

      ACCEPT:
        sent: [signature]
        checks:
          - "Normalize signed_fields according to canonicalization"
          - "signature matches"
          - "delta_transfer.scope is compatible"

      REVERSE:
        trigger: "DCS validation_fail etc."
        sent: [reversal_signal.events, "Return of unresolved Δ"]
        checks: ["authority_revoked -> Force AI->Human"]

  security_governance:
    canonicalization:
      - "json_c14n / yaml_c14n"
      - "Fix field order"
      - "Eliminate variations in whitespace / newlines"
    
    signed_fields: [handshake_meta, world, agent, trust, interface, decision_authority, resolution_policy]
    
    replay_protection: [nonce unique, timestamp ±5min, expires_at mandatory]
    
    authority_safety:
      - "intent=decision -> risk_level>=2"
      - "irreversible=true -> Human-Closed"
      - "validation_fail -> AI->Human"
    
    delta_safety:
      - "scope: prompt / artifact / state / tool_call"
      - "redaction: required / optional / forbidden"

  vcdesign_alignment:
    Chapter: "continuity_claim.boundary_def"
    Boundary: "world.id"
    Responsibility: "decision_authority.domain"
    RC: "resolution_policy"
    DCS: "reversal_signal"
    BOA_RCA: "trust.validation_level / semantics.intent"

  license: "MIT License"
